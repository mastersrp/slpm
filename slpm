#!/bin/sh
# suckless package manager @ 2009-2010
# - pancake at nopcode dot org

whereami() {
  for a in $PWD `echo $PATH | sed 's,:, ,g'` ; do
    if [ -e "$a/$1" ]; then
      echo "$a/$1"
      return
    fi
  done
  echo $1
}

lslibs() {
  cd ${PREFIX}
  export LD_LIBRARY_PATH=${PREFIX}/lib
  for bin in `find bin usr/bin` ; do
    [ ! -f $bin ] && continue
    [ ! -x $bin ] && continue
    ldd $bin | cut -d '>' -f 2- |cut -c 2-| grep ^/ | cut -d ' ' -f 1 | grep -v ${PREFIX}
  done
}

fixlibs() {
 libs=$(lslibs |sort |uniq)
 for a in $libs ; do
   ba=$(basename $a)
   if [ ! -e "${PREFIX}/lib/$ba" ]; then
     echo $a
   fi
 done
}

BIN="`readlink $0`"
[ -z "${BIN}" ] && BIN=$0
[ -z "${BIN}" ] && BIN=/bin/sh # XXX?
ARG0="`whereami $BIN`"
ROOT="`dirname $ARG0`"
IGNEXE=0
USRDIR="${HOME}/.slpm"
WRKDIR="${ROOT}/_work"
PKGDIR="${ROOT}/pkg"
PTXDIR="${ROOT}/patches"
BINPKGDIR="${ROOT}/binpkg"
MAKE=make
. "${ROOT}/config"
md5sum --help >/dev/null 2>&1
if [ $? = 0 ]; then
	CHKSUM=md5sum
else
	CHKSUM=md5
fi
NFODIR="${DESTDIR}/${PREFIX}/var/lib/slpm/pkg"
BINPKG=0
if [ -n "${SYSDEPS}" ]; then
  igncmd="grep -v $(echo "-e$SYSDEPS" | sed -e 's, , -e,g')"
else
  igncmd="cat"
fi
export igncmd

configure_environment() {
  PATH=${DESTDIR}${PREFIX}/bin:${DESTDIR}${PREFIX}/sbin:${PATH}
  MANPATH=${PREFIX}/share/man:${MANPATH}
  LD_LIBRARY_PATH=${PREFIX}/lib:${LD_LIBRARY_PATH}
  PKG_CONFIG_PATH=${PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}
  XDG_DATA_DIRS=${PREFIX}/share:${XDG_DATA_DIRS}
  CFLAGS="-I${PREFIX}/include"
  LDFLAGS="-L${PREFIX}/lib"
  unset PROMPT_COMMAND
  export CFLAGS LDFLAGS PREFIX
  export PATH MANPATH LD_LIBRARY_PATH PKG_CONFIG_PATH XDG_DATA_DIRS
}

# XXX a bit spaguetti
hg_fetch() {
  cd $WRKDIR
  if [ -d "$1" ]; then
    if [ "$3" = 1 ]; then
      echo "==> hg: updating $1 ..."
      ( cd "$1" ; hg pull && hg up )
    fi
  else
    hg clone "$2" "$1"
  fi
}

svn_fetch() {
  cd $WRKDIR
  if [ -d "$1" ]; then
    if [ "$3" = 1 ]; then
      echo "==> svn: updating $1 ..."
      ( cd "$1" ; svn up )
    fi
  else
    svn co "$2" "$1"
  fi
}

git_fetch() {
  cd "$WRKDIR"
  if [ -d "$1" ]; then
    if [ "$3" = 1 ]; then
      ( cd "$1" ; git pull )
    fi
  else
    git clone "$2" "$1"
  fi
}

tar_fetch() {
  FILE="`basename $URL`"
  cd "$WRKDIR"
  if [ -f "$WRKDIR/$FILE" ]; then
    echo "==> Already downloaded $FILE"
  else
    wget -c $URL
  fi
  if [ -d "$WRKDIR/$PKG" ]; then
    echo "==> Already uncompressed and patched $PKG"
  else
    case "$FILE" in
    *gz*) tar xzvf $FILE ; ;;
    *bz2*) tar xjvf $FILE ; ;;
    *xz*) xz -d $FILE ; FILE2=`echo $FILE|sed -e s,.xz,,`; tar xvf $FILE2 ; ;;
    esac
  fi
}

pkg_fetch() {
  eval ${TYPE}_fetch $PKG $URL $1
}

pkg_update() {
  hg_fetch $PKG $URL
}

pkg_patch() {
  if [ -n "${PATCHES}" ]; then
    pushd ${WRKDIR}/${PKG}/${BASEDIR} > /dev/null
    if [ -e .patch_executed ]; then
      echo "=> Patches already applied."
    else
      echo "=> Patching ${PKG}.."
      for a in ${PATCHES} ; do
        patch -p1 < ${PTXDIR}/${a}.patch
      done
      :> .patch_executed
    fi
    popd > /dev/null
  fi
}

pkg_unpatch() {
  if [ -n "${PATCHES}" ]; then
    pushd ${WRKDIR}/${PKG}/${BASEDIR} >/dev/null
    if [ -e .patch_executed ]; then
      echo "=> Unpatching ${PKG}.."
      for a in ${PATCHES} ; do
        patch -R -p1 < ${PTXDIR}/${a}.patch
      done
      rm -f .patch_executed
    else
      echo "=> Patches already not applied."
    fi
    popd > /dev/null
  fi
}

pkg_build() {
  cd "$WRKDIR/$PKG/${BASEDIR}"
  [ "${IGNEXE}" = 1 ] && rm -f .configure_executed .build_executed
  if [ -e .configure_executed ]; then
    echo "=> Not running ./configure because of .configure_executed"
  else
    if [ -n "${PKGCONFIGURE}" ]; then
      ${PKGCONFIGURE}
    else
      [ -f configure ] && chmod +x configure
      if [ -x "configure" ]; then
        ./configure "--prefix=${PREFIX}" ${CFGARGS} ${USER_CFGARGS}
        if [ ! $? = 0 ]; then
          echo "=> Configure stage failed :("
          exit 1
        fi
      fi
    fi
    :> .configure_executed
  fi
  if [ -e .build_executed ]; then
    echo "=> Not running ${MAKE} because of .build_executed"
  else
    ${MAKE} DESTDIR=${DESTDIR} PREFIX=${PREFIX} prefix=${PREFIX}
    if [ ! $? = 0 ]; then
      echo "=> Make stage failed :("
      exit 1
    fi
    :> .build_executed
  fi
}

pkg_install() {
  if [ ! -d "$WRKDIR/$PKG/${BASEDIR}" ]; then
    echo "pkg_install: Cannot open target directory"
    exit 1
  fi
  (
    cd "$WRKDIR/$PKG/${BASEDIR}"
    if [ -n "${INSTALL_PRE}" ]; then
      echo "=> Running pre install script '${INSTALL_PRE}'"
      (cd ${DESTDIR}/${PREFIX} ; eval $INSTALL_PRE)
    fi
    echo "=> Running: ${PKGINSTALL} ${PKGINSTALL_ARGS}"
    eval ${PKGINSTALL} ${PKGINSTALL_ARGS}
    if [ -n "${INSTALL_POST}" ]; then
      echo "=> Running post install script '${INSTALL_POST}'"
      (cd ${DESTDIR}/${PREFIX} ; eval $INSTALL_POST)
    fi
  )
  pkg_register
}

pkg_chksum() {
  if [ ! -e $NFODIR/$PKG/chksum ]; then
    echo "Cannot find chksum database for $PKG"
    return
  fi
  echo "# ${PKG}"
  for a in `cat $NFODIR/$PKG/files` ; do
    orig=`grep $a$ $NFODIR/$PKG/chksum | awk '{print $1}'`
    cur=`$CHKSUM "${DESTDIR}/${PREFIX}/$a" | awk '{print $1}'`
    if [ "$orig" = "$cur" ]; then
      echo ". $orig $cur $a"
    else
      echo "x $orig $cur $a"
    fi
  done
}

pkg_register_chksum() {
  PKGNAME=$1
  ( cd ${DESTDIR}/${PREFIX}
    for a in `cat $NFODIR/$PKGNAME/files` ; do
      ${CHKSUM} "$a"
    done
  ) > $NFODIR/$PKGNAME/chksum
}

binpkg_register() {
  PKGNAME=`basename $PKG | sed -e s,slpm-,, -e s,.tgz,,`
  echo "=> Register binary package $PKGNAME"
  mkdir -p $NFODIR/$PKGNAME
  tar tzf $PKG | grep -v /$ | grep -v slpm.nfo > $NFODIR/$PKGNAME/files
  pkg_register_chksum ${PKGNAME}
  mv ${DESTDIR}/${PREFIX}/slpm.nfo $NFODIR/$PKGNAME/slpm.nfo
  date > "$NFODIR/$PKGNAME/date"
}

binpkg_install() {
  echo "=> Installing binary package"
  tar xzvf $PKG -C ${DESTDIR}/${PREFIX} | grep -v slpm.nfo | grep -v /$
  binpkg_register
}

pkg_register() {
  [ -d "$NFODIR/$PKG/${BASEDIR}" ] && return
  cd "$WRKDIR/$PKG/${BASEDIR}"
  # TODO: move outside and create skel in a standard way
  mkdir -p "${WRKDIR}/.tmp/${PKG}"
  mkdir -p "${WRKDIR}/.tmp/${PKG}/bin"
  mkdir -p "${WRKDIR}/.tmp/${PKG}/lib"
  mkdir -p "${WRKDIR}/.tmp/${PKG}/man/man1"
## XXX: dupped from pkg_install
    if [ -n "${INSTALL_PRE}" ]; then
      echo "=> Running pre install script '${INSTALL_PRE}'"
      (cd ${WRKDIR}/.tmp/${PKG} ; eval $INSTALL_PRE)
    fi
  echo "=> Running ${PKGINSTALL} PREFIX=/ "DESTDIR=${WRKDIR}/.tmp/${PKG}" prefix=/"
  eval ${PKGINSTALL} PREFIX=/ "DESTDIR=${WRKDIR}/.tmp/${PKG}" prefix=/
#"prefix=${WRKDIR}/.tmp/${PKG}"
## XXX: dupped from pkg_install
    if [ -n "${INSTALL_POST}" ]; then
      echo "=> Running post install script '${INSTALL_POST}'"
      (cd ${WRKDIR}/.tmp/${PKG} ; eval $INSTALL_POST)
    fi
  # go register
  cd "${WRKDIR}/.tmp/${PKG}"
  echo "${WRKDIR}/.tmp/${PKG}"
  mkdir -p "$NFODIR/$PKG"
  if [ -n "`ls`" ]; then
    _pfx=`pwd | cut -c 2-`
    (find * -type f ; find * -type l ) | \
      sed -e "s,$_pfx,," > "$NFODIR/$PKG/files"
    echo "=> Create binary package: ${BINPKGDIR}/slpm-${PKG}.tgz"
    cp ${PKGDIR}/${PKG} slpm.nfo
    tar czf ${BINPKGDIR}/slpm-${PKG}.tgz *
    pkg_register_chksum ${PKG}
  else
    echo "==> WARNING: Package have installed no files"
    : > "$NFODIR/$PKG/files"
  fi
  date > "$NFODIR/$PKG/date"
  cp ${PKGDIR}/${PKG} $NFODIR/$PKG/slpm.nfo
  rm -rf "${WRKDIR}/.tmp/${PKG}"
}

pkg_clean() {
  cd "$WRKDIR/$PKG"
  rm -f .configure_executed .build_executed
  ${MAKE} clean
}

pkg_deinstall() {
  if [ -e "$NFODIR/$PKG/files" ]; then
    cd "${DESTDIR}/${PREFIX}"
    for a in `cat $NFODIR/$PKG/files`; do
      [ -f "./$a" ] && echo "./$a" && rm -f "./$a"
    done
    rm -rf "$NFODIR/$PKG"
  else
    if [ -d "$WRKDIR/$PKG" ]; then
      cd "$WRKDIR/$PKG"
# TODO: wrap into ${PKGDEINSTALL}
      ${MAKE} uninstall DESTDIR=${DESTDIR} PREFIX=${PREFIX}
    fi
  fi
}

help() {
  echo "Usage: slpm [-iudlLx] [pkg pkg ..]"
  echo " -x : execute or enter into the slpm shell"
  echo " -u : upgrade package"
  echo " -i : install package (.tgz or pkgname)"
  echo " -d : deinstall package"
  echo " -c : clean package"
  echo " -C : check checksum of pkg files (u,m=un,modified)"
  echo " -s : search package by keyword"
  echo " -l : list installed packages or pkg files"
  echo " -L : list all available packages (-LL for description)"
  echo " -f : find missing libraries (-fi: install, -fl: list, -fd: remove)"
  echo " -p : patch package"
  echo " -P : unpatch package"
  exit 1
}

exec_shell() {
  SHELL=""
  [ -x "${PREFIX}/bin/rc" ] && SHELL="${PREFIX}/bin/rc"
  [ -x "${PREFIX}/bin/ksh" ] && SHELL="${PREFIX}/bin/ksh"
  [ -x "${PREFIX}/bin/dash" ] && SHELL="${PREFIX}/bin/dash"
  [ -x "${PREFIX}/bin/sh" ] && SHELL="${PREFIX}/bin/sh"
  if [ -z "${SHELL}" ]; then
    echo "Cannot find shell. Please install dash, busybox or 9base"
    exit 1
  fi
  configure_environment
  PATH=${DESTDIR}${PREFIX}/bin:${DESTDIR}${PREFIX}/sbin:${PATH}
  MANPATH=${PREFIX}/share/man:${MANPATH}
  LD_LIBRARY_PATH=${PREFIX}/lib:${LD_LIBRARY_PATH}
  PKG_CONFIG_PATH=${PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}
  unset PROMPT_COMMAND
  export PATH MANPATH LD_LIBRARY_PATH PKG_CONFIG_PATH
  if [ -z "$1" ]; then
    eval ${SHELL}
  else
    eval $@
  fi
  exit $?
}

mkdir -p "${NFODIR}" "${WRKDIR}" "${BINPKGDIR}"
[ ! -e "${NFODIR}/.fixedlibs" ] && touch ${NFODIR}/.fixedlibs

DO=
while [ -n "$1" ]; do
  case "$1" in
  -f) fixlibs ; exit 0 ; ;;
  -fi)
    mkdir -p ${DESTDIR}/${PREFIX}/lib
    for a in `fixlibs` ; do
      cp $a ${DESTDIR}/${PREFIX}/lib
      echo $(basename $a) >> ${NFODIR}/.fixedlibs
    done
    exit 0
    ;;
  -fl) cat ${NFODIR}/.fixedlibs ; exit 0 ; ;;
  -fd)
    for a in $(cat ${NFODIR}/.fixedlibs) ; do
      echo $a
      rm -f ${DESTDIR}/${PREFIX}/lib/$a
    done
    :> ${NFODIR}/.fixedlibs
    exit 0
    ;;
  -x) shift ; exec_shell $@ ; ;;
  -h) help ; ;;
  -p|-P|-c|-C|-i|-I|-u|-d) DO=$1 ; ;;
  -s)
    if [ -z "$2" ]; then
      echo "Usage: slpm -s [keyword]"
    else
      cd ${PKGDIR} && grep DESC * | grep -i "$2"
    fi
    exit 0
    ;;
  -L) ls ${PKGDIR} | cat ; exit 0 ; ;;
  -LL)
     for a in `ls ${PKGDIR}`; do
       . ${PKGDIR}/$a
       printf "%20s  $DESC\n" $a
     done ; exit 0 ; ;;
  -ll)
     cd ${NFODIR}
     for a in `echo *`; do
       if [ -e "${NFODIR}/$a/slpm.nfo" ]; then
         . ${NFODIR}/$a/slpm.nfo
         printf "%20s  $DESC\n" $a
       else
         printf "%20s  (no description)\n" $a
       fi
     done
     exit 0
    ;;
  -l)
    if [ -z "$2" ]; then
      ls "$NFODIR" | cat ; exit 0
    else
      if [ ! -d "$NFODIR/$2" ]; then
        PKGNAME=`basename $NFODIR/$2* 2> /dev/null` # autocomplete
        if [ ! -d "$NFODIR/$PKGNAME" ]; then
          echo "Package $2 not installed" ; exit 1
        else
          cat "$NFODIR/$PKGNAME/files" ; exit 0
        fi
      else
        cat "$NFODIR/$2/files" ; exit 0
      fi
    fi
    ;;
  -*) echo "Unknown flag '$1'" ;;
  *) break ;;
  esac
  shift
done

pkg_open() {
  MSG=""
  URL=""
  TYPE="tar"
  DESC=""
  DEPS=""
  CFGARGS=""
  BASEDIR=""
  INSTALL_POST="" # script to run after install
  PKGINSTALL="${MAKE} install"
  PKGINSTALL_ARGS="DESTDIR=${DESTDIR} PREFIX=${PREFIX} prefix=${PREFIX}"
  PKGCONFIGURE=""
  BINPKG=0
  if [ -n "${REMOTE}" ]; then
    here=$(pwd)
    cd ${BINPKGDIR}
    eval ${WGET} ${REMOTE}/slpm-${PKG}.tgz
    if [ $? = 0 ]; then
      PKG=${BINPKGDIR}/slpm-${PKG}.tgz
    else
      echo "=> Cannot find this package remotely"
    fi
    cd ${here}
  fi

  if [ "`echo $PKG|grep .tgz$`" ]; then
    tar xvzf ${PKG} slpm.nfo
    if [ ! $? = 0 ]; then
      echo "This is not a binary slpm package"
      exit 1
    fi
    . ./slpm.nfo
    rm -f slpm.nfo
    BINPKG=1
    return
  fi

# hack to support to uninstall packages without finding the pkg description
# XXX this needs to be fixed
if [ "$DO" = "-d" ]; then
  if [ -f "$NFODIR/$PKG/slpm.nfo" ]; then
    . "${NFODIR}/$PKG/slpm.nfo"
  else
    PKG2=`basename $NFODIR/$PKG* 2> /dev/null` # autocomplete
    if [ -f "$NFODIR/$PKG2/slpm.nfo" ]; then
      . "${NFODIR}/${PKG2}/slpm.nfo"
      PKG=$PKG2
    else
      echo "Cannot find $PKG"
      exit 1
    fi
  fi
  return
fi

  if [ ! -f "$PKGDIR/$PKG" ]; then
    PKG2=`basename $PKGDIR/$PKG* 2> /dev/null` # autocomplete
    if [ ! -f "$PKGDIR/$PKG2" ]; then
      echo "Cannot find $PKG"
      exit 1
    fi
    PKG=$PKG2
  fi
  . "${PKGDIR}/$PKG"
  if [ -e "${USRDIR}/$PKG" ]; then
    . "${USRDIR}/$PKG"
  fi
  # TODO: check package variables
  if [ -z "${URL}" ]; then echo "No URL defined in package"; fi
  if [ -z "${TYPE}" ]; then echo "No TYPE defined in package"; fi
  for DEP in ${DEPS}; do
    if [ -z "`echo $a | $igncmd`" ]; then
      printf "=> Checking dependency $DEP"
      slpm -l | grep ${DEP}
      if [ $? = 0 ]; then
        echo "=> OK"
      else
        echo "=> Not found. Installing pkg..."
        slpm -i ${DEP}
      fi
      continue
    fi
    if [ ! -e "${NFODIR}/${DEP}" ]; then
      echo "=> Installing missing dependency ${DEP}"
      $0 -i ${DEP}
      if [ ! $? = 0 ]; then
        echo "=> Install of ${DEP} has failed"
        exit 1
      fi
    fi
  done
  if [ -n "${MSG}" ]; then
    echo ""
    echo "=="
    echo "  ${MSG}"
    echo "=="
    echo ""
    sleep 1
  fi
}

[ -z "$1" ] && help
configure_environment
while [ -n "$1" ]; do
  PKG=$1
  pkg_open
  case $DO in
  -C) (pkg_chksum) ; ;;
  -c) (pkg_clean) ; ;;
  -p) (pkg_patch) ; ;;
  -P) (pkg_unpatch) ; ;;
  -i) if [ ${BINPKG} = 1 ]; then
        (binpkg_install)
      else
        (pkg_fetch) && (pkg_patch) && (pkg_build) && (pkg_install) 
      fi ; ;;
  -u) (pkg_fetch 1) && (pkg_clean) ; (pkg_build) && (pkg_install) ; ;;
  -d) (pkg_deinstall) ; ;;
  *) (pkg_fetch) ; ;;
  esac
  shift
done
